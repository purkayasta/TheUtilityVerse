/// <summary>
/// Author: Pritom Purkayasta
//  Copyright (c) Pritom Purkayasta All rights reserved.
//  FREE TO USE TO CONNECT THE WORLD
/// </summary>

using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace UtilityVerse.Copy.Generators;

internal static class DeepCopyGenerator
{
    internal static string? Generate(INamedTypeSymbol typeSymbol)
    {
        if (typeSymbol.IsAbstract) return string.Empty;
        if (!Helper.IsPartial(typeSymbol)) return string.Empty;

        var isGlobalNamespace = typeSymbol.ContainingNamespace.IsGlobalNamespace;
        var namespaceName = isGlobalNamespace ? null : typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;

        var typeKind = typeSymbol switch
        {
            { TypeKind: TypeKind.Class, IsRecord: true } => "record",
            { TypeKind: TypeKind.Struct, IsRecord: true } => "record struct",
            { TypeKind: TypeKind.Class } => "class",
            { TypeKind: TypeKind.Struct } => "struct",
            _ => null
        };

        if (typeKind == null)
            return string.Empty;

        var sb = new StringBuilder();

        sb.AppendLine("""

                        // <auto-generated>
                        //     This code was generated by Copy.
                        //     Author: Pritom Purkayasta
                        //     DO NOT modify this file manually. Changes may be overwritten.
                        //     This file contains auto-generated DeepCopy() implementations.
                        // </auto-generated>

                        using System;
                        using System.Linq;
                        using System.Collections.Generic;
                        using System.Collections.ObjectModel;
                        using System.Collections.Immutable;
                        using System.Collections.Concurrent;
                        using System.Collections.Frozen;

                      """);

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    public partial {typeKind} {typeName}");
        sb.AppendLine("    {");
        sb.AppendLine("        [System.CodeDom.Compiler.GeneratedCode(\"DeepCopyGenerator\", \"1.0\")]");
        sb.AppendLine($"        public {typeName} DeepCopy()");
        sb.AppendLine("        {");

        var hasParameterlessCtor = typeSymbol.InstanceConstructors.Any(c => c.Parameters.Length == 0);

        if (!hasParameterlessCtor)
        {
            var ctor = typeSymbol.InstanceConstructors
                .OrderByDescending(c => c.Parameters.Length)
                .FirstOrDefault();

            if (ctor != null)
            {
                var args = ctor.Parameters.Select(p =>
                {
                    var prop = Helper.GetAllProperties(typeSymbol)
                        .FirstOrDefault(m => m.Name.Equals(p.Name, System.StringComparison.OrdinalIgnoreCase));

                    if (prop == null)
                        return $"default({p.Type.ToDisplayString()})";

                    return Helper.IsTrulyPrimitive(prop.Type)
                        ? $"this.{prop.Name}"
                        : $"this.{prop.Name}?.DeepCopy()";
                });

                sb.AppendLine($"            return new {typeName}({string.Join(", ", args)});");
            }
            else
            {
                // No constructor found - return empty string (no code generated)
                if (!string.IsNullOrEmpty(namespaceName))
                    sb.AppendLine("        }");
                sb.AppendLine("    }");
                if (!string.IsNullOrEmpty(namespaceName))
                    sb.AppendLine("}");
                return string.Empty;
            }
        }
        else
        {
            sb.AppendLine($@"            return new {typeName}
            {{");

            foreach (var member in Helper.GetAllProperties(typeSymbol))
            {
                if (member.IsReadOnly || member.SetMethod is null)
                    continue;

                var propType = member.Type;
                string assignment;

                if (Helper.IsTrulyPrimitive(propType))
                {
                    assignment = $"this.{member.Name}";
                }
                else switch (propType)
                    {
                        case IArrayTypeSymbol arrayType:
                            {
                                var elementType = arrayType.ElementType;
                                assignment = Helper.IsTrulyPrimitive(elementType)
                                    ? $"this.{member.Name}?.ToArray()"
                                    : $"this.{member.Name}?.Select(x => x?.DeepCopy()).ToArray()";
                                break;
                            }
                        case INamedTypeSymbol { IsGenericType: true } named:
                            {
                                var original = named.OriginalDefinition.ToDisplayString();
                                var typeArgs = named.TypeArguments;

                                if (Helper.IsGenericCollection(original, out var collectionKind))
                                {
                                    var elementType = typeArgs[0];
                                    var cloneExpr = Helper.IsTrulyPrimitive(elementType)
                                        ? "x"
                                        : "x?.DeepCopy()";

                                    if (collectionKind == "HashSet")
                                    {
                                        assignment =
                                            $"this.{member.Name} != null ? new HashSet<{elementType.ToDisplayString()}>(this.{member.Name}.Select(x => {cloneExpr}).ToList()) : null";
                                    }
                                    else if (collectionKind == "Dictionary")
                                    {
                                        var keyType = typeArgs[0];
                                        var valueType = typeArgs[1];

                                        var keyCopy = Helper.IsTrulyPrimitive(keyType) ? "x.Key" : "x.Key?.DeepCopy()";
                                        var valueCopy = Helper.IsTrulyPrimitive(valueType) ? "x.Value" : "x.Value?.DeepCopy()";

                                        assignment = $"this.{member.Name}?.ToDictionary(x => {keyCopy}, x => {valueCopy})";
                                    }
                                    else
                                    {
                                        // For List, IEnumerable, Collection, ReadOnlyCollection, etc.
                                        assignment = $"this.{member.Name}?.Select(x => {cloneExpr}).ToList()";
                                    }
                                }
                                else if (original == "System.Collections.Generic.Dictionary<TKey, TValue>")
                                {
                                    var keyType = typeArgs[0];
                                    var valueType = typeArgs[1];

                                    assignment = $"this.{member.Name}?.ToDictionary(" +
                                                 $"x => {(Helper.IsTrulyPrimitive(keyType) ? "x.Key" : "x.Key?.DeepCopy()")}, " +
                                                 $"x => {(Helper.IsTrulyPrimitive(valueType) ? "x.Value" : "x.Value?.DeepCopy()")})";
                                }
                                else if (original.StartsWith("System.Tuple") || original.StartsWith("System.ValueTuple"))
                                {
                                    var tupleArgs = typeArgs.Select((arg, i) =>
                                        Helper.IsTrulyPrimitive(arg) ? $"x.Item{i + 1}" : $"x.Item{i + 1}?.DeepCopy()");

                                    assignment = $"this.{member.Name} is {{ }} x ? new {propType.ToDisplayString()}({string.Join(", ", tupleArgs)}) : default";
                                }
                                else
                                {
                                    assignment = $"this.{member.Name}?.DeepCopy()";
                                }

                                break;
                            }
                        default:
                            assignment = $"this.{member.Name}?.DeepCopy()";
                            break;
                    }

                sb.AppendLine($"                {member.Name} = {assignment},");
            }

            sb.AppendLine(@"            };");
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
}